//! Represents a single part of the response content from the Gemini API, typically text.
//!
//! This struct can hold either text generated by the model or a function call.
//! Multiple `PartResponse` instances can exist within a `ContentResponse`.
//! Uses fully qualified paths for dependencies.
//! Part of the `ContentResponse` structure.

#[derive(Debug, serde::Deserialize)]
pub struct PartResponse {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<std::string::String>,
    #[serde(rename = "functionCall", skip_serializing_if = "Option::is_none")]
    pub function_call: Option<crate::vendors::gemini::function_call_response::FunctionCallResponse>,
    #[serde(rename = "inlineData", skip_serializing_if = "Option::is_none")]
    pub inline_data: Option<crate::vendors::gemini::inline_data::InlineData>,
}

#[cfg(test)]
mod tests {
    // Use super::PartResponse for the struct under test.
    // Use std::string::String for String, Option.
    // Use serde_json for JSON manipulation.
    // Use crate::vendors::gemini::function_call_response::FunctionCallResponse for the nested type.

    #[test]
    fn test_part_response_text_only_deserialization() {
        let json_data = r#"{"text": "Hello world"}"#;
        let part: super::PartResponse = serde_json::from_str(json_data).unwrap();
        assert_eq!(part.text, Some(std::string::String::from("Hello world")));
        assert!(part.function_call.is_none());
    }

    #[test]
    fn test_part_response_function_call_only_deserialization() {
        let json_data = r#"{
            "functionCall": {
                "name": "do_something",
                "args": { "value": 42 }
            }
        }"#;
        let part: super::PartResponse = serde_json::from_str(json_data).unwrap();
        assert!(part.text.is_none());
        assert!(part.function_call.is_some());
        let func_call = part.function_call.unwrap();
        assert_eq!(func_call.name, "do_something");
        assert_eq!(func_call.args, serde_json::json!({ "value": 42 }));
    }

    #[test]
    fn test_part_response_empty_part_deserialization() {
        // It's possible for a part to be empty, or have other fields not modeled here.
        // The current model expects at least one of text or functionCall if they are present.
        // If both are truly optional and can be absent, this test shows current behavior.
        let json_data = r#"{}"#; // An empty part
        let part: super::PartResponse = serde_json::from_str(json_data).unwrap();
        assert!(part.text.is_none());
        assert!(part.function_call.is_none());
    }

    // Serialization tests are less critical for response structs, but can be added if needed.
}
