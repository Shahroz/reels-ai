//! Defines the events sent by the AgentLoop service to clients over WebSocket.
//!
//! This enum encapsulates all possible messages pushed from the server to the client,
//! including status updates, tool results, intermediate answers, the final answer,
//! and termination notices.
//! Adheres to the one-item-per-file guideline and uses fully qualified paths.
//! Follows standard Rust coding conventions and derives necessary traits.

//! Revision History
//! - 2025-04-24T19:16:02Z @AI: Add IntermediateAnswer variant per request.
//! - 2025-04-24T18:22:48Z @AI: Add FinalAnswer variant. Fix syntax errors.
//! - 2025-04-24T12:44:14Z @AI: Initial implementation based on data_structures.md and instruction.

// Note: Using fully qualified paths for types as per guidelines.
// External crate imports are acceptable if needed for traits/macros.
use serde::{Serialize, Deserialize};
use actix::Message;
use schemars::JsonSchema;
use utoipa::ToSchema;
// Required for #[rtype] macro

#[derive(Debug, Clone, Serialize, Deserialize, Message, ToSchema, JsonSchema)]
#[rtype(result = "()")] // Specifies the return type for actix::Handler
pub enum WebsocketEvent {
    /// Streamed reasoning or status updates from the agent.
    ReasoningUpdate(String),
    /// Result of a tool execution initiated by the agent.
    ToolExecutionSuccess(crate::types::user_tool_response::UserToolResponse),
    ToolExecutionFailure(crate::types::user_tool_failure::UserToolFailure),
    /// Feedback from the background context evaluator.
    ContextFeedback(crate::types::context_evaluator_feedback::ContextEvaluatorFeedback),
    /// Current session status and optional time remaining.
    StatusUpdate(crate::types::status_response::StatusResponse),
    /// The answer generated by the agent for the user, indicating if it's final.
    AgentAnswer {
        /// The content of the answer.
        content: String,
        /// Flag indicating if this is the final answer for the current research goal.
        is_final: bool,
    },
    /// A final research answer, typically including a title and detailed content.
    /// Used when the agent signals the final answer (`LlmAgentResponse.is_final = true`).
    ResearchAnswer {
        /// The title of the final research report or answer.
        title: String,
        /// The full content of the final research report or answer.
        content: String,
    },
    /// Indicates session completion, timeout, or forced termination.
    SessionTerminated {
        /// The ID of the terminated session.
        session_id: String,
        /// An optional reason for the termination.
        reason: Option<String>,
    },
}

// Note: No tests are included as this is primarily a data structure definition.
// Testing would typically occur at the serialization/deserialization layer or
// where these events are constructed and consumed.
#[cfg(test)]
mod tests {
    use schemars::schema_for;
    // use crate::types::tool_result::{ToolResult, ToolResultStatus}; // This import might become unused by this specific test block after changes.

    // Helper to create a basic ToolResult for testing ToolExecution variant
    fn create_dummy_tool_result() -> ToolResult {
        ToolResult {
            tool_name: "dummy_tool".to_string(),
            session_id: "dummy_session".to_string(),
            status: ToolResultStatus::Success,
            output: "Dummy output".to_string(),
            error: None,
        }
    }

    use crate::types::tool_result::{ToolResult, ToolResultStatus}; // Keep for create_dummy_tool_result, though its direct use in test_other_variants_serialization is removed.
    use crate::types::ws_event::WebsocketEvent;

    #[test]
    #[test]
    fn get_schema() {
        // This test ensures the schema generation works with the current structure.
        // It's useful to update this if the structure changes significantly.
        let schema = schema_for!(WebsocketEvent);
        // Print the schema for verification during test runs (optional)
        println!("{}", serde_json::to_string_pretty(&schema).unwrap());
        // Basic assertion to ensure schema generation didn't panic
        assert!(serde_json::to_string(&schema).is_ok());
    }

    #[test]
    fn test_research_answer_serialization() {
        let event = WebsocketEvent::ResearchAnswer {
            title: "Final Report".to_string(),
            content: "This is the answer.".to_string(),
        };
        let serialized = serde_json::to_string(&event).unwrap();
        assert!(serialized.contains("\"ResearchAnswer\""));
        assert!(serialized.contains("\"title\":\"Final Report\""));
        assert!(serialized.contains("\"content\":\"This is the answer.\""));

        let deserialized: WebsocketEvent = serde_json::from_str(&serialized).unwrap();
        match deserialized {
            WebsocketEvent::ResearchAnswer { title, content } => {
                assert_eq!(title, "Final Report");
                assert_eq!(content, "This is the answer.");
            }
            _ => panic!("Deserialized into wrong variant"),
        }
    }

    #[test]
    fn test_other_variants_serialization() {
        // Just basic checks to ensure other variants serialize without error
        let reason_event = WebsocketEvent::ReasoningUpdate("Thinking...".to_string());
        assert!(serde_json::to_string(&reason_event).is_ok());

        let success_tool_response = crate::types::user_tool_response::UserToolResponse {
            tool_name: std::string::String::from("success_tool"),
            summary: std::string::String::from("Successfully executed"),
            icon: std::option::Option::None,
            data: std::option::Option::None,
        };
        let success_event = WebsocketEvent::ToolExecutionSuccess(success_tool_response);
        assert!(serde_json::to_string(&success_event).is_ok());

        let failure_tool_info = crate::types::user_tool_failure::UserToolFailure {
            tool_name: std::string::String::from("failure_tool"),
            error: std::string::String::from("An error occurred"),
        };
        let failure_event = WebsocketEvent::ToolExecutionFailure(failure_tool_info);
        assert!(serde_json::to_string(&failure_event).is_ok());


        let feedback_data = crate::types::context_evaluator_feedback::ContextEvaluatorFeedback { session_id: std::string::String::from("s1"), feedback: std::string::String::from("Good context") };
        let feedback_event = WebsocketEvent::ContextFeedback(feedback_data);
        assert!(serde_json::to_string(&feedback_event).is_ok());

        let status_data = crate::types::status_response::StatusResponse { session_id: std::string::String::from("s1"), status: crate::types::session_status::SessionStatus::Running { progress: std::option::Option::None }, time_remaining_secs: std::option::Option::Some(120) };
        let status_event = WebsocketEvent::StatusUpdate(status_data);
        assert!(serde_json::to_string(&status_event).is_ok());

        let terminated_event = WebsocketEvent::SessionTerminated { session_id: std::string::String::from("s1"), reason: std::option::Option::Some(std::string::String::from("Completed")) };
        assert!(serde_json::to_string(&terminated_event).is_ok());
    }
}
